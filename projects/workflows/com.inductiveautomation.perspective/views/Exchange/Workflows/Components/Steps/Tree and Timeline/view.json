{
  "custom": {
    "poll": 1,
    "steps": null,
    "workflow": null
  },
  "params": {
    "workflowId": ""
  },
  "propConfig": {
    "custom.poll": {
      "binding": {
        "config": {
          "path": "view.custom.workflow[0].status"
        },
        "transforms": [
          {
            "fallback": 1,
            "inputType": "scalar",
            "mappings": [
              {
                "input": "SUCCESS",
                "output": 0
              },
              {
                "input": "CANCELLED",
                "output": 0
              }
            ],
            "outputType": "scalar",
            "type": "map"
          }
        ],
        "type": "property"
      },
      "persistent": true
    },
    "custom.steps": {
      "binding": {
        "config": {
          "parameters": {
            "workflowId": "{view.params.workflowId}"
          },
          "polling": {
            "enabled": true,
            "rate": "{view.custom.poll}"
          },
          "queryPath": "Exchange/Workflows/Workflows/Steps/ListByWorkflow",
          "returnFormat": "dataset"
        },
        "transforms": [
          {
            "code": "\t# Perspective Script Transform\n\t# Input (value): steps dataset/list\n\t# Uses: workflow metadata\n\t# Output: {\"gantt\": {...}, \"tree\": {...}}\n\t\n\tdef _to_rows(v):\n\t\tif v is None:\n\t\t\treturn []\n\t\tif isinstance(v, list):\n\t\t\treturn v\n\t\ttry:\n\t\t\tpy \u003d system.dataset.toPyDataSet(v)\n\t\t\tout \u003d []\n\t\t\tfor r in py:\n\t\t\t\tout.append({\n\t\t\t\t\t\"call_seq\": r[\"call_seq\"],\n\t\t\t\t\t\"step_name\": r[\"step_name\"],\n\t\t\t\t\t\"status\": r[\"status\"],\n\t\t\t\t\t\"output_json\": r[\"output_json\"],\n\t\t\t\t\t\"error_json\": r[\"error_json\"],\n\t\t\t\t\t\"started_at_epoch_ms\": r[\"started_at_epoch_ms\"],\n\t\t\t\t\t\"completed_at_epoch_ms\": r[\"completed_at_epoch_ms\"],\n\t\t\t\t\t\"attempts\": r[\"attempts\"],\n\t\t\t\t})\n\t\t\treturn out\n\t\texcept:\n\t\t\treturn []\n\t\n\tdef _as_long(x, default\u003dNone):\n\t\ttry:\n\t\t\tif x is None:\n\t\t\t\treturn default\n\t\t\treturn long(x)\n\t\texcept:\n\t\t\ttry:\n\t\t\t\treturn long(str(x))\n\t\t\texcept:\n\t\t\t\treturn default\n\t\n\tdef _norm_status(s):\n\t\ts \u003d (s or \"\").upper().strip()\n\t\tif not s:\n\t\t\treturn \"UNKNOWN\"\n\t\treturn s\n\t\n\tdef _is_terminal(s):\n\t\ts \u003d _norm_status(s)\n\t\treturn s in (\"SUCCESS\", \"ERROR\", \"FAILED\", \"CANCELLED\", \"CANCELED\", \"COMPLETED\")\n\t\n\tdef _tree_icon_for_status(status):\n\t\t# Keep it simple: use built-in Material icons\n\t\ts \u003d _norm_status(status)\n\t\tif s \u003d\u003d \"SUCCESS\":\n\t\t\treturn {\"path\": \"material/check_circle\"}\n\t\tif s in (\u0027ERROR\u0027, \u0027FAILED\u0027):\n\t\t\treturn {\"path\": \"material/error\"}\n\t\tif s in (\"CANCELLED\", \"CANCELED\"):\n\t\t\treturn {\"path\": \"material/cancel\"}\n\t\tif s in (\"RUNNING\", \"STARTED\"):\n\t\t\treturn {\"path\": \"material/autorenew\"}\n\t\tif s in (\"PENDING\", \"ENQUEUED\", \"QUEUED\"):\n\t\t\treturn {\"path\": \"material/schedule\"}\n\t\treturn {\"path\": \"material/help\"}\n\tdef _mode_color(mode):\n\t\tm \u003d _norm_status(mode)\n\t\tif m \u003d\u003d \"SUCCESS\":\n\t\t\treturn \"#0aa648\"\n\t\tif m in (\"ERROR\", \"FAILED\"):\n\t\t\treturn \"#de1b1b\"\n\t\tif m in (\"CANCELLED\", \"CANCELED\"):\n\t\t\treturn \"#a1a1a1\"\n\t\tif m in (\"RUNNING\", \"STARTED\"):\n\t\t\treturn \"#5691f0\"\n\t\tif m in (\"PENDING\", \"ENQUEUED\", \"QUEUED\"):\n\t\t\treturn \"#cf7911\"\n\t\treturn \"#bdbdbd\"\n\tdef _fmt_duration(ms):\n\t\t\"\"\"Compact duration string for tooltips.\"\"\"\n\t\ttry:\n\t\t\tms \u003d long(ms)\n\t\texcept:\n\t\t\treturn \"—\"\n\t\n\t\tif ms \u003c 1000:\n\t\t\treturn \"%d ms\" % ms\n\t\n\t\ts \u003d ms / 1000.0\n\t\tif s \u003c 60:\n\t\t\treturn \"%.3f s\" % s\n\t\n\t\tm \u003d int(s // 60)\n\t\trs \u003d s - (m * 60)\n\t\treturn \"%dm %06.3fs\" % (m, rs)\n\n\n\tnow_ms \u003d system.date.toMillis(system.date.now())\n\t\n\t# --- workflow meta ---\n\tmeta \u003d self.custom.workflow[0] if self.custom.workflow[0] else None\n\twf_name \u003d str(meta.get(\"workflow_name\") or meta.get(\"name\") or \"Workflow\")\n\twf_status \u003d _norm_status(meta.get(\"status\"))\n\twf_start \u003d _as_long(meta.get(\"started_at_epoch_ms\"))\n\twf_completed \u003d _as_long(meta.get(\"completed_at_epoch_ms\"))\n\t\n\twf_running \u003d (wf_completed is None) and (not _is_terminal(wf_status))\n\twf_end_effective \u003d now_ms if wf_running else (wf_completed if wf_completed is not None else now_ms)\n\t\n\t# --- steps ---\n\trows \u003d _to_rows(value)\n\t\n\titems \u003d []\n\tany_step_running \u003d False\n\t\n\tfor r in rows:\n\t\tcall_seq \u003d int(r.get(\"call_seq\") or 0)\n\t\tstep_name \u003d str(r.get(\"step_name\") or \"—\")\n\t\tst \u003d _norm_status(r.get(\"status\"))\n\t\n\t\ts \u003d _as_long(r.get(\"started_at_epoch_ms\"))\n\t\te \u003d _as_long(r.get(\"completed_at_epoch_ms\"))\n\t\n\t\tif s is None:\n\t\t\tcontinue\n\t\n\t\tif e is None:\n\t\t\te \u003d now_ms\n\t\t\tany_step_running \u003d True\n\t\t\tif st in (\"UNKNOWN\", \"\"):\n\t\t\t\tst \u003d \"RUNNING\"\n\t\n\t\te \u003d max(e, s)\n\t\tdur_ms \u003d max(0, e - s)\n\t\tdur_text \u003d _fmt_duration(dur_ms)\n\t\tlabel \u003d \"%03d  %s\" % (call_seq, step_name)\n\t\n\t\titems.append({\n\t\t\t\"call_seq\": call_seq,\n\t\t\t\"label\": label,\n\t\t\t\"step_name\": step_name,\n\t\t\t\"status\": st,\n\t\t\t\"start\": s,\n\t\t\t\"end\": e,\n\t\t\t\"attempts\": int(r.get(\"attempts\") or 1),\n\t\t\t\"output_json\": r.get(\"output_json\"),\n\t\t\t\"error_json\": r.get(\"error_json\"),\n\t\t\t\"duration_ms\": long(dur_ms),\n\t\t\t\"duration_text\": dur_text,\n\t\t})\n\t\n\titems.sort(key\u003dlambda x: x[\"call_seq\"])\n\t\n\t# --- range ---\n\tif wf_start is None:\n\t\twf_start \u003d min([it[\"start\"] for it in items]) if items else now_ms\n\t\n\tmax_step_end \u003d max([it[\"end\"] for it in items]) if items else now_ms\n\trange_end \u003d now_ms if (wf_running or any_step_running) else max(wf_end_effective, max_step_end)\n\t\n\t# --- workflow mode ---\n\tif wf_status !\u003d \"UNKNOWN\":\n\t\twf_mode \u003d wf_status\n\telse:\n\t\twf_mode \u003d \"RUNNING\" if (wf_running or any_step_running) else \"SUCCESS\"\n\t\tif not (wf_running or any_step_running) and any(it[\"status\"] in (\"ERROR\", \"FAILED\") for it in items):\n\t\t\twf_mode \u003d \"ERROR\"\n\t\n\t# --- modes ---\n\tmode_set \u003d {}\n\tmode_set[wf_mode] \u003d True\n\tfor it in items:\n\t\tmode_set[it[\"status\"]] \u003d True\n#\tmodes \u003d [{\"name\": k} for k in sorted(mode_set.keys())]\n\tmodes \u003d [{\"name\": k, \"color\": _mode_color(k)} for k in sorted(mode_set.keys())]\n\t\n\t# --- gantt data ---\n\tgantt_data \u003d []\n\twf_dur_ms \u003d max(0, range_end - wf_start)\n\twf_dur_text \u003d _fmt_duration(wf_dur_ms)\n\t\n\tgantt_data.append({\n\t\t\"name\": wf_name,\n\t\t\"events\": [{\n\t\t\t\"start\": long(wf_start),\n\t\t\t\"end\": long(range_end if (wf_running or any_step_running) else wf_end_effective),\n\t\t\t\"mode\": wf_mode,\n\t\t\t\"duration_ms\": long(wf_dur_ms),\n\t\t\t\"duration_text\": wf_dur_text\n\t\t}]\n\t})\n\t\n\tfor it in items:\n\t\tgantt_data.append({\n\t\t\t\"name\": it[\"label\"],\n\t\t\t\"events\": [{\n\t\t\t\t\"start\": long(it[\"start\"]),\n\t\t\t\t\"end\": long(it[\"end\"]),\n\t\t\t\t\"mode\": it[\"status\"],\n\t\t\t\t\"duration_ms\": long(it[\"duration_ms\"]),\n\t\t\t\t\"duration_text\": it[\"duration_text\"],\n\t\t\t\t\"attempts\": it[\"attempts\"]\n\t\t\t}]\n\t\t})\n\t\n\tgantt \u003d {\n\t\t\"data\": gantt_data,\n\t\t\"modes\": modes,\n\t\t\"range\": {\"start\": long(wf_start), \"end\": long(range_end)}\n\t}\n\t\n\t# --- tree items (piggy-back from the same parsed items) ---\n\ttree_children \u003d []\n\tfor it in items:\n\t\ttree_children.append({\n\t\t\t\"label\": it[\"label\"],\n\t\t\t\"icon\": _tree_icon_for_status(it[\"status\"]),\n\t\t\t\"data\": {\n\t\t\t\t\"call_seq\": it[\"call_seq\"],\n\t\t\t\t\"step_name\": it[\"step_name\"],\n\t\t\t\t\"status\": it[\"status\"],\n\t\t\t\t\"attempts\": it[\"attempts\"],\n\t\t\t\t\"started_at_epoch_ms\": long(it[\"start\"]),\n\t\t\t\t\"completed_at_epoch_ms\": None if it[\"end\"] \u003d\u003d now_ms and _as_long(it.get(\"end\")) \u003d\u003d now_ms and _norm_status(it[\"status\"]) \u003d\u003d \"RUNNING\" else long(it[\"end\"]),\n\t\t\t\t\"output_json\": it[\"output_json\"],\n\t\t\t\t\"error_json\": it[\"error_json\"]\n\t\t\t}\n\t\t})\n\t\n\ttree \u003d [{\n\t\t\t\"label\": wf_name,\n\t\t\t\"expanded\": True,\n\t\t\t\"icon\": _tree_icon_for_status(wf_mode),\n\t\t\t\"data\": {\"status\": wf_mode},\n\t\t\t\"items\": tree_children\n\t\t}]\n\t\n\treturn {\"gantt\": gantt, \"tree\": tree}",
            "type": "script"
          }
        ],
        "type": "query"
      },
      "persistent": true
    },
    "custom.workflow": {
      "binding": {
        "config": {
          "parameters": {
            "workflowId": "{view.params.workflowId}"
          },
          "polling": {
            "enabled": true,
            "rate": "{view.custom.poll}"
          },
          "queryPath": "Exchange/Workflows/Workflows/GetOne",
          "returnFormat": "json"
        },
        "type": "query"
      },
      "persistent": true
    },
    "params.workflowId": {
      "paramDirection": "input",
      "persistent": true
    }
  },
  "props": {
    "defaultSize": {
      "height": 836
    }
  },
  "root": {
    "children": [
      {
        "meta": {
          "name": "Tree"
        },
        "position": {
          "shrink": 0
        },
        "propConfig": {
          "props.items": {
            "binding": {
              "config": {
                "path": "view.custom.steps.tree"
              },
              "type": "property"
            }
          }
        },
        "props": {
          "appearance": {
            "defaultNodeIcons": {
              "collapsed": {
                "path": "material/folder"
              },
              "empty": {
                "path": "material/stop"
              },
              "expanded": {
                "path": "material/folder_open"
              }
            },
            "expandIcons": {
              "collapsed": {
                "path": "material/arrow_right"
              },
              "expanded": {
                "path": "material/arrow_drop_down"
              }
            }
          }
        },
        "type": "ia.display.tree"
      },
      {
        "meta": {
          "name": "Template"
        },
        "position": {
          "basis": "320px",
          "grow": 1
        },
        "propConfig": {
          "props.params.data": {
            "binding": {
              "config": {
                "path": "view.custom.steps.gantt.data"
              },
              "type": "property"
            }
          },
          "props.params.modes": {
            "binding": {
              "config": {
                "path": "view.custom.steps.gantt.modes"
              },
              "type": "property"
            }
          },
          "props.params.range": {
            "binding": {
              "config": {
                "path": "view.custom.steps.gantt.range"
              },
              "type": "property"
            }
          }
        },
        "props": {
          "params": {
            "exampleData": false,
            "instanceID": "ModeTimeline",
            "update": {
              "onChange": true
            }
          },
          "path": "Exchange/Workflows/Components/Ribbon Chart/Template"
        },
        "type": "ia.display.view"
      }
    ],
    "meta": {
      "name": "root"
    },
    "type": "ia.container.flex"
  }
}